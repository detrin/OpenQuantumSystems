var documenterSearchIndex = {"docs":
[{"location":"tutorials/A/#","page":"A site","title":"A site","text":"CurrentModule=OpenQuantumSystems","category":"page"},{"location":"tutorials/A/#A-site-1","page":"A site","title":"A site","text":"","category":"section"},{"location":"tutorials/A/#","page":"A site","title":"A site","text":"Example Julia package repo.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"CurrentModule=OpenQuantumSystems","category":"page"},{"location":"#OpenQuantumSystems-1","page":"Home","title":"OpenQuantumSystems","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"OpenQuantumSystems.jl may help you with simulating common open quantum systems with main focus on systems connected to quantum biology. ","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Documentation is under construction. ","category":"page"},{"location":"#","page":"Home","title":"Home","text":"(Image: under construction)","category":"page"},{"location":"#Installation-1","page":"Home","title":"Installation","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"You can obtain OpenQuantumSystems using Julia's Pkg REPL-mode (hitting ] as the first character of the command prompt):","category":"page"},{"location":"#","page":"Home","title":"Home","text":"(v1.6) pkg> add OpenQuantumSystems","category":"page"},{"location":"#","page":"Home","title":"Home","text":"or with using Pkg; Pkg.add(\"OpenQuantumSystems\").","category":"page"},{"location":"#Documentation-1","page":"Home","title":"Documentation","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"Modules = [OpenQuantumSystems]","category":"page"},{"location":"#OpenQuantumSystems.Aggregate","page":"Home","title":"OpenQuantumSystems.Aggregate","text":"Aggregate{T,C1,C2}(molecules, coupling)\nAggregate{T,C1,C2}(molecules)\n\nMutable stuct which purpose is to store important information about the whole system.\n\nArguments\n\nmolecules: Vector of molecules (Molecule).\ncoupling: Matrix of couplings J_nm between molecules.\n\n\n\n\n\n","category":"type"},{"location":"#OpenQuantumSystems.AnnihilationOperator","page":"Home","title":"OpenQuantumSystems.AnnihilationOperator","text":"AnnihilationOperator{BL,BR}(basis_l, basis_r)\n\nDense annihilation operator as a mutable struct.\n\n\n\n\n\n","category":"type"},{"location":"#OpenQuantumSystems.CreationOperator","page":"Home","title":"OpenQuantumSystems.CreationOperator","text":"CreationOperator{BL,BR}(basis_l, basis_r)\n\nDense creation operator as a mutable struct.\n\n\n\n\n\n","category":"type"},{"location":"#OpenQuantumSystems.Mode","page":"Home","title":"OpenQuantumSystems.Mode","text":"Mode{T}(omega, shift)\n\nMutable stuct which purpose is to model vibrational LHO mode in Molecule.\n\nV(q) = hbar omega (q - q_0)^2 quad hbar = 1\n\nArguments\n\nomega: The frequency of LHO (omega).\nshift: The shift of the coordinate of LHO (q_0).\n\n\n\n\n\n","category":"type"},{"location":"#OpenQuantumSystems.Molecule","page":"Home","title":"OpenQuantumSystems.Molecule","text":"Molecule{T,C1,C2}(modes, Nvib, E)\n\nMutable stuct which purpose is to model a molecule in Aggregate.\n\nArguments\n\nmodes: Vector of modes (Mode).\nNvib: Maximum number of vibrational states for all modes.\nE: Energy of ground and excited state of molecule (HOMO, LUMO).\n\n\n\n\n\n","category":"type"},{"location":"#OpenQuantumSystems.Commutator-Tuple{Operator}","page":"Home","title":"OpenQuantumSystems.Commutator","text":"Commutator(A)\n\nCreate commutator in a form of superoperator from a given operator.\n\ntextCommutator(A) cdot = A cdot\n\n\n\n\n\n","category":"method"},{"location":"#OpenQuantumSystems.OneDenseOperator-Union{Tuple{BR}, Tuple{BL}, Tuple{BL, BR}} where {BL<:Basis, BR<:Basis}","page":"Home","title":"OpenQuantumSystems.OneDenseOperator","text":"OneDenseOperator(basis_l, basis_r)\n\nDenseOperator with ones on the diagonal.\n\n\n\n\n\n","category":"method"},{"location":"#OpenQuantumSystems.electronicIndices-Tuple{T} where T<:Integer","page":"Home","title":"OpenQuantumSystems.electronicIndices","text":"electronicIndices(molCount; groundState = true)\n\nGet the electric indices for all states on Aggregate.\n\nArguments\n\nmolCount: Number of molecules in Aggregate.\ngroundState: Option for allowing the ground electric state in local basis.\n\n\n\n\n\n","category":"method"},{"location":"#OpenQuantumSystems.electronicIndices-Union{Tuple{Aggregate{T, C1, C2}}, Tuple{C2}, Tuple{C1}, Tuple{T}} where {T<:Integer, C1<:Union{AbstractFloat, Complex}, C2<:Union{AbstractFloat, Complex}}","page":"Home","title":"OpenQuantumSystems.electronicIndices","text":"vibrationalIndices(agg; groundState = true)\n\nGet all electronic indices of the Aggregate.\n\nArguments\n\nagg: Instance of Aggregate.\ngroundState: Option for allowing the ground electric state in local basis.\n\n\n\n\n\n","category":"method"},{"location":"#OpenQuantumSystems.evolutionApproximate!-Union{Tuple{C}, Tuple{Array{Matrix{C}, 1}, Operator, Array, Operator}} where C<:Union{AbstractFloat, Complex}","page":"Home","title":"OpenQuantumSystems.evolutionApproximate!","text":"evolutionApproximate!(op_array, op0, tspan, Hamiltonian)\n\nCalculate approximate time evolution of the op0 inplace based on U(t) that is  calculated for t_0 and t_textstep. See evolutionOperator. This method returns Vector of Arrays.\n\n\n\n\n\n","category":"method"},{"location":"#OpenQuantumSystems.evolutionApproximate!-Union{Tuple{C}, Tuple{Array{Vector{C}, 1}, Ket, Array, Operator}} where C<:Union{AbstractFloat, Complex}","page":"Home","title":"OpenQuantumSystems.evolutionApproximate!","text":"evolutionApproximate!(ket_array, ket0, tspan, Hamiltonian)\n\nCalculate approximate time evolution of the ket0 inplace based on U(t) that is  calculated for t_0 and t_textstep. See evolutionOperator. Argument ket_array is Vector of Arrays.\n\n\n\n\n\n","category":"method"},{"location":"#OpenQuantumSystems.evolutionApproximate-Tuple{Ket, Array, Operator}","page":"Home","title":"OpenQuantumSystems.evolutionApproximate","text":"evolutionApproximate(ket0, tspan, Hamiltonian)\n\nCalculate approximate time evolution of the ket0 based on U(t) that is  calculated for t_0 and t_textstep. See evolutionOperator. This method returns Vector of Ket states.\n\n\n\n\n\n","category":"method"},{"location":"#OpenQuantumSystems.evolutionApproximate-Tuple{Operator, Array, Operator}","page":"Home","title":"OpenQuantumSystems.evolutionApproximate","text":"evolutionApproximate(op0, tspan, Hamiltonian)\n\nCalculate approximate time evolution of the op0 based on U(t) that is  calculated for t_0 and t_textstep. See evolutionOperator. This method returns Vector of Operators.\n\n\n\n\n\n","category":"method"},{"location":"#OpenQuantumSystems.evolutionExact!-Union{Tuple{C}, Tuple{Array{Matrix{C}, 1}, Operator, Array, Operator}} where C<:Union{AbstractFloat, Complex}","page":"Home","title":"OpenQuantumSystems.evolutionExact!","text":"evolutionExact!(op_array, op0, tspan, Hamiltonian; \n\tdiagonalize = true, approximate = false)\n\nCalculate exact time evolution of the op0 state inplace see evolutionOperatorIterator.  The diagonalize argument decompose Hamiltonian into lambda_i S S^-1 and calculate the exponential using eigenvalue decomposition. The approximate option asusmes that tspan is made of  equidistant points, therefore U(t) has to be calculated for t_0 and t_textstep.\n\n\n\n\n\n","category":"method"},{"location":"#OpenQuantumSystems.evolutionExact!-Union{Tuple{C}, Tuple{Array{Vector{C}, 1}, Ket, Array, Operator}} where C<:Union{AbstractFloat, Complex}","page":"Home","title":"OpenQuantumSystems.evolutionExact!","text":"evolutionExact!(ket_array, ket0, tspan, Hamiltonian; \n\tdiagonalize = true, approximate = false)\n\nCalculate exact time evolution of the ket0 state inplace see evolutionOperatorIterator.  The diagonalize argument decompose Hamiltonian into lambda_i S S^-1 and calculate the exponential using eigenvalue decomposition. The approximate option asusmes that tspan is made of  equidistant points, therefore U(t) has to be calculated for t_0 and t_textstep.\n\n\n\n\n\n","category":"method"},{"location":"#OpenQuantumSystems.evolutionExact-Tuple{Ket, Array, Operator}","page":"Home","title":"OpenQuantumSystems.evolutionExact","text":"evolutionExact(ket0, tspan, Hamiltonian; diagonalize = true, approximate = false)\n\nCalculate exact time evolution of the ket0 state see evolutionOperatorIterator.  The diagonalize argument decompose Hamiltonian into lambda_i S S^-1 and calculate the exponential using eigenvalue decomposition. The approximate option asusmes that tspan is made of  equidistant points, therefore U(t) has to be calculated for t_0 and t_textstep.\n\n\n\n\n\n","category":"method"},{"location":"#OpenQuantumSystems.evolutionExact-Tuple{Operator, Array, Operator}","page":"Home","title":"OpenQuantumSystems.evolutionExact","text":"evolutionExact(op0, tspan, Hamiltonian; diagonalize = true, approximate = false)\n\nCalculate exact time evolution of the op0 state see evolutionOperatorIterator.  The diagonalize argument decompose Hamiltonian into lambda_i S S^-1 and calculate the exponential using eigenvalue decomposition. The approximate option asusmes that tspan is made of  equidistant points, therefore U(t) has to be calculated for t_0 and t_textstep.\n\n\n\n\n\n","category":"method"},{"location":"#OpenQuantumSystems.evolutionOperator-Tuple{Operator, AbstractFloat}","page":"Home","title":"OpenQuantumSystems.evolutionOperator","text":"evolutionOperator(Hamiltonian, t)\n\nGet evolution operator as Operator using the definition\n\nU(t) = e^-i H t  hbar quad hbar = 1.\n\n\n\n\n\n","category":"method"},{"location":"#OpenQuantumSystems.evolutionOperatorA-Tuple{Array, Array, Array, AbstractFloat}","page":"Home","title":"OpenQuantumSystems.evolutionOperatorA","text":"evolutionOperatorA(H_lambda, S, Sinv, t)\n\nGet evolution operator as Array using the definition\n\nU(t) = S e^-i H_lambda t  hbar S^-1\n\nwhere hbar = 1, H_lambdaii = lambda_i are eigenvalues of H, so H has to be non-singular, otherwise H_lambdaij = 0 i neq j.  S is obtained from eigendecomposition of H, for example\n\nH_lambda, S = eigen(Hamiltonian.data)\nSinv = inv(S)\nH_lambda = diagm(H_lambda)\n\nand arguments have to be Arrays.\n\n\n\n\n\n","category":"method"},{"location":"#OpenQuantumSystems.evolutionOperatorArray-Tuple{Operator, Array}","page":"Home","title":"OpenQuantumSystems.evolutionOperatorArray","text":"evolutionOperatorArray(Hamiltonian, tspan)\n\nGet evolution operators as Vector or Operators using the definition\n\nU(t) = e^-i H t  hbar quad hbar = 1.\n\n\n\n\n\n","category":"method"},{"location":"#OpenQuantumSystems.evolutionOperatorIterator","page":"Home","title":"OpenQuantumSystems.evolutionOperatorIterator","text":"evolutionOperatorIterator(Hamiltonian, tspan; diagonalize = true, approximate = false)\n\nResumable function that returns evolution operator as Operator type at the time t from tspan. See evolutionOperator. The diagonalize argument decompose Hamiltonian into lambda_i S S^-1 and calculate the exponential using eigenvalue decomposition. The approximate option asusmes that tspan is made of  equidistant points, therefore U(t) has to be calculated for t_0 and t_textstep.\n\n\n\n\n\n","category":"function"},{"location":"#OpenQuantumSystems.evolutionSuperOperator-Tuple{Operator, AbstractFloat}","page":"Home","title":"OpenQuantumSystems.evolutionSuperOperator","text":"evolutionSuperOperator(Hamiltonian, t)\n\nGet evolution operator as SuperOperator using the definition\n\nmathcalU(t) cdot = U(t) cdot U^dagger(t) = e^-i H t  hbar cdot e^i H t  hbar quad hbar = 1.\n\n\n\n\n\n","category":"method"},{"location":"#OpenQuantumSystems.evolutionSuperOperatorArray-Tuple{Operator, Array}","page":"Home","title":"OpenQuantumSystems.evolutionSuperOperatorArray","text":"evolutionOperatorArray(Hamiltonian, tspan)\n\nGet evolution superoperators as Vector or SuperOperators using the definition\n\nmathcalU(t) cdot = U(t) cdot U^dagger(t) = e^-i H t  hbar cdot e^i H t  hbar quad hbar = 1.\n\n\n\n\n\n","category":"method"},{"location":"#OpenQuantumSystems.evolutionSuperOperatorIterator","page":"Home","title":"OpenQuantumSystems.evolutionSuperOperatorIterator","text":"evolutionSuperOperatorIterator(Hamiltonian, tspan; \n\tdiagonalize = true, approximate = false)\n\nResumable function that returns evolution operator as Operator type at the time t from tspan. See evolutionSuperOperator. The diagonalize argument decompose Hamiltonian into lambda_i S S^-1 and calculate the exponential using eigenvalue decomposition. The approximate option asusmes that tspan is made of  equidistant points, therefore U(t) has to be calculated for t_0 and t_textstep.\n\n\n\n\n\n","category":"function"},{"location":"#OpenQuantumSystems.evolution_approximate-Union{Tuple{U}, Tuple{T}, Tuple{B}, Tuple{T, Array, U}} where {B<:Basis, T<:(Operator{B, B, T} where T), U<:(Operator{B, B, T} where T)}","page":"Home","title":"OpenQuantumSystems.evolution_approximate","text":"evolution_exact(rho0, tspan, Hamiltonian; diagonalize = false)\n\nCalculate approximate time evolution of the rho0 based on U(t) that is  calculated for t_0 and t_textstep. The diagonalize argument decompose Hamiltonian into lambda_i S S^-1 and calculate the exponential using eigenvalue decomposition. See evolutionOperator. This method returns tspan and Vector of Operators.\n\n\n\n\n\n","category":"method"},{"location":"#OpenQuantumSystems.evolution_exact-Union{Tuple{U}, Tuple{T}, Tuple{B}, Tuple{T, Array, U}} where {B<:Basis, T<:(Operator{B, B, T} where T), U<:(Operator{B, B, T} where T)}","page":"Home","title":"OpenQuantumSystems.evolution_exact","text":"evolution_exact(rho0, tspan, Hamiltonian; diagonalize = false)\n\nCalculate exact time evolution of the rho0 inplace based on U(t).  The diagonalize argument decompose Hamiltonian into lambda_i S S^-1 and calculate the exponential using eigenvalue decomposition. See evolutionOperator. This method returns tspan and Vector of Operators.\n\n\n\n\n\n","category":"method"},{"location":"#OpenQuantumSystems.franckCondonFactors-Union{Tuple{U}, Tuple{T}, Tuple{T, U}} where {T<:Integer, U<:Union{AbstractFloat, Complex}}","page":"Home","title":"OpenQuantumSystems.franckCondonFactors","text":"franckCondonFactors(size, shift)\n\nGet Franck-Condon factors for LHO mode calculated using ShiftOperator.\n\n\n\n\n\n","category":"method"},{"location":"#OpenQuantumSystems.getAggHamSysBath-Union{Tuple{C2}, Tuple{C1}, Tuple{T}, Tuple{Aggregate{T, C1, C2}, Any}} where {T<:Integer, C1<:Union{AbstractFloat, Complex}, C2<:Union{AbstractFloat, Complex}}","page":"Home","title":"OpenQuantumSystems.getAggHamSysBath","text":"getAggHamSysBath(agg, aggIndices; groundState = false, groundEnergy = false)\n\nGet Hamiltonian of the system and of the bath, H_S + H_B by generating Hamiltonian  with zero Mode shifts.\n\nArguments\n\nagg: Instance of Aggregate.\naggIndices: Aggregate indices generated by getIndices.\nfranckCondonFactors: Franck-Condon factors generated by getFranckCondonFactors.\ngroundState: Option for allowing the ground electric state in local basis.\n\n\n\n\n\n","category":"method"},{"location":"#OpenQuantumSystems.getAggHamSysBath2-Union{Tuple{C2}, Tuple{C1}, Tuple{T}, Tuple{Aggregate{T, C1, C2}, Any}} where {T<:Integer, C1<:Union{AbstractFloat, Complex}, C2<:Union{AbstractFloat, Complex}}","page":"Home","title":"OpenQuantumSystems.getAggHamSysBath2","text":"getAggHamSysBath2(agg, aggIndices; groundState = false, groundEnergy = false)\n\nGet Hamiltonian of the system and of the bath, H_S + H_B by multiplication Hilbert  spaces of the system and of the bath.\n\nArguments\n\nagg: Instance of Aggregate.\naggIndices: Aggregate indices generated by getIndices.\nfranckCondonFactors: Franck-Condon factors generated by getFranckCondonFactors.\ngroundState: Option for allowing the ground electric state in local basis.\n\n\n\n\n\n","category":"method"},{"location":"#OpenQuantumSystems.getAggHamiltonian-Union{Tuple{C2}, Tuple{C1}, Tuple{T}, Tuple{Aggregate{T, C1, C2}, Any, Any}} where {T<:Integer, C1<:Union{AbstractFloat, Complex}, C2<:Union{AbstractFloat, Complex}}","page":"Home","title":"OpenQuantumSystems.getAggHamiltonian","text":"getAggHamiltonian(agg, aggIndices, \n\tfranckCondonFactors; groundState = false, groundEnergy = false)\ngetAggHamiltonian(agg, aggIndices; groundState = false, groundEnergy = false)\ngetAggHamiltonian(agg; groundState = false, groundEnergy = false)\n\nGet Hamiltonian of the Aggregate in a form of DenseOperator.\n\nArguments\n\nagg: Instance of Aggregate.\naggIndices: Aggregate indices generated by getIndices.\nfranckCondonFactors: Franck-Condon factors generated by getFranckCondonFactors.\ngroundState: Option for allowing the ground electric state in local basis.\n\n\n\n\n\n","category":"method"},{"location":"#OpenQuantumSystems.getAggHamiltonianBath-Union{Tuple{Aggregate{T, C1, C2}}, Tuple{C2}, Tuple{C1}, Tuple{T}} where {T<:Integer, C1<:Union{AbstractFloat, Complex}, C2<:Union{AbstractFloat, Complex}}","page":"Home","title":"OpenQuantumSystems.getAggHamiltonianBath","text":"getAggHamiltonianBath(agg)\n\nGet Hamiltonian of the bath, H_B.\n\n\n\n\n\n","category":"method"},{"location":"#OpenQuantumSystems.getAggHamiltonianInteraction-Union{Tuple{C2}, Tuple{C1}, Tuple{T}, Tuple{Aggregate{T, C1, C2}, Any, Any}} where {T<:Integer, C1<:Union{AbstractFloat, Complex}, C2<:Union{AbstractFloat, Complex}}","page":"Home","title":"OpenQuantumSystems.getAggHamiltonianInteraction","text":"getAggHamiltonianInteraction(agg, aggIndices, franckCondonFactors; \n\tgroundState = false, groundEnergy = false)\ngetAggHamiltonianInteraction(agg, aggIndices; groundState = false, groundEnergy = false)\ngetAggHamiltonianInteraction(agg; groundState = false, groundEnergy = false)\n\nGet interation Hamiltonian of the Aggregate, H_textint by substracting  Hamiltonian and Hamiltonian of the systems and of the bath, H - H_S - H_B.\n\nArguments\n\nagg: Instance of Aggregate.\naggIndices: Aggregate indices generated by getIndices.\nfranckCondonFactors: Franck-Condon factors generated by getFranckCondonFactors.\ngroundState: Option for allowing the ground electric state in local basis.\n\n\n\n\n\n","category":"method"},{"location":"#OpenQuantumSystems.getAggHamiltonianSparse-Union{Tuple{C2}, Tuple{C1}, Tuple{T}, Tuple{Aggregate{T, C1, C2}, Any, Any}} where {T<:Integer, C1<:Union{AbstractFloat, Complex}, C2<:Union{AbstractFloat, Complex}}","page":"Home","title":"OpenQuantumSystems.getAggHamiltonianSparse","text":"getAggHamiltonianSparse(agg, aggIndices; groundState = true)\ngetAggHamiltonianSparse(agg; groundState = true)\n\nSparse version of getAggHamiltonian.\n\n\n\n\n\n","category":"method"},{"location":"#OpenQuantumSystems.getAggHamiltonianSystem-Union{Tuple{Aggregate{T, C1, C2}}, Tuple{C2}, Tuple{C1}, Tuple{T}} where {T<:Integer, C1<:Union{AbstractFloat, Complex}, C2<:Union{AbstractFloat, Complex}}","page":"Home","title":"OpenQuantumSystems.getAggHamiltonianSystem","text":"getAggHamiltonianSystem(agg; groundState = false)\n\nGet Hamiltonian of the system, H_S.\n\nArguments\n\nagg: Instance of Aggregate.\ngroundState: Option for allowing the ground electric state in local basis.\n\n\n\n\n\n","category":"method"},{"location":"#OpenQuantumSystems.getAggStateEnergy-Union{Tuple{U}, Tuple{C2}, Tuple{C1}, Tuple{T}, Tuple{Aggregate{T, C1, C2}, Vector{U}, Array{Vector{U}, 1}}} where {T<:Integer, C1<:Union{AbstractFloat, Complex}, C2<:Union{AbstractFloat, Complex}, U<:Integer}","page":"Home","title":"OpenQuantumSystems.getAggStateEnergy","text":"getAggStateEnergy(agg, aggElState, aggVibState)\n\nGet Hamiltonian of the Aggregate in a form of DenseOperator.\n\nArguments\n\nagg: Instance of Aggregate.\naggElState: Aggregate electric state (e.g. [1, 1, 2]).\naggVibState: Aggregate vibrational state (e.g. [[9, 1], [2, 5, 3], [10]]).\n\n\n\n\n\n","category":"method"},{"location":"#OpenQuantumSystems.getFranckCondonFactors-Union{Tuple{C2}, Tuple{C1}, Tuple{T}, Tuple{Aggregate{T, C1, C2}, Any}} where {T<:Integer, C1<:Union{AbstractFloat, Complex}, C2<:Union{AbstractFloat, Complex}}","page":"Home","title":"OpenQuantumSystems.getFranckCondonFactors","text":"getFranckCondonFactors(agg, aggIndices; groundState = true)\ngetFranckCondonFactors(agg; groundState = true)\n\nGet Frack-Condon factors of the Aggregate in a form of matrix.\n\nArguments\n\nagg: Instance of Aggregate.\naggIndices: Aggregate indices generated by getIndices.\ngroundState: Option for allowing the ground electric state in local basis.\n\n\n\n\n\n","category":"method"},{"location":"#OpenQuantumSystems.getFranckCondonFactorsSparse-Union{Tuple{C2}, Tuple{C1}, Tuple{T}, Tuple{Aggregate{T, C1, C2}, Any}} where {T<:Integer, C1<:Union{AbstractFloat, Complex}, C2<:Union{AbstractFloat, Complex}}","page":"Home","title":"OpenQuantumSystems.getFranckCondonFactorsSparse","text":"getFranckCondonFactorsSparse(agg, aggIndices; groundState = true)\ngetFranckCondonFactorsSparse(agg; groundState = true)\n\nSparse version of getFranckCondonFactors.\n\n\n\n\n\n","category":"method"},{"location":"#OpenQuantumSystems.getIndices-Union{Tuple{Aggregate{T, C1, C2}}, Tuple{C2}, Tuple{C1}, Tuple{T}} where {T<:Integer, C1<:Union{AbstractFloat, Complex}, C2<:Union{AbstractFloat, Complex}}","page":"Home","title":"OpenQuantumSystems.getIndices","text":"getIndices(agg; groundState = true)\n\nGet all indices (electronic and vibrational) of the Aggregate.\n\nArguments\n\nagg: Instance of Aggregate.\ngroundState: Option for allowing the ground electric state in local basis.\n\n\n\n\n\n","category":"method"},{"location":"#OpenQuantumSystems.getMolStateEnergy-Union{Tuple{U}, Tuple{C2}, Tuple{C1}, Tuple{T}, Tuple{Molecule{T, C1, C2}, U, Vector{U}}} where {T<:Integer, C1<:Union{AbstractFloat, Complex}, C2<:Union{AbstractFloat, Complex}, U<:Integer}","page":"Home","title":"OpenQuantumSystems.getMolStateEnergy","text":"getMolStateEnergy(mol, molElState, molVibState)\n\nGet the energy of the Molecule state.\n\nArguments\n\nmol: Instance of Molecule.\nmolElState: Electric state of the molecule in local basis (i.e. 1 or 2, where 1 is ground state).\nmolVibState: Vibrational state of the molecule (e.g. [1, 5, 2, 2]).\n\n\n\n\n\n","category":"method"},{"location":"#OpenQuantumSystems.getMolStateFC-Union{Tuple{U}, Tuple{C2}, Tuple{C1}, Tuple{T}, Tuple{Molecule{T, C1, C2}, U, Vector{U}, U, Vector{U}}} where {T<:Integer, C1<:Union{AbstractFloat, Complex}, C2<:Union{AbstractFloat, Complex}, U<:Integer}","page":"Home","title":"OpenQuantumSystems.getMolStateFC","text":"getMolStateFC(mol, molElState1, molVibState1, molElState2, molVibState2)\n\nGet the energy of the Molecule state.\n\nArguments\n\nmol: Instance of Molecule.\nmolElState1, molElState2: Electric state of the molecule in local basis (i.e. 1 or 2, where 1 is ground state).\nmolVibState1, molVibState2: Vibrational state of the molecule (e.g. [1, 5, 2, 2]).\n\n\n\n\n\n","category":"method"},{"location":"#OpenQuantumSystems.getNvib-Union{Tuple{Aggregate{T, C1, C2}}, Tuple{C2}, Tuple{C1}, Tuple{T}} where {T<:Integer, C1<:Union{AbstractFloat, Complex}, C2<:Union{AbstractFloat, Complex}}","page":"Home","title":"OpenQuantumSystems.getNvib","text":"getNvib(agg)\n\nGet maximum number of vibrational states of each molecule in the Aggregate.\n\n\n\n\n\n","category":"method"},{"location":"#OpenQuantumSystems.getVibIndices-Tuple{Any, Any}","page":"Home","title":"OpenQuantumSystems.getVibIndices","text":"getVibIndices(agg; groundState = true)\n\nGet pointers (integers) to the indices of the Aggregate separated by  electronic states (e.g. [[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]]).\n\nArguments\n\nagg: Instance of Aggregate.\ngroundState: Option for allowing the ground electric state in local basis.\n\n\n\n\n\n","category":"method"},{"location":"#OpenQuantumSystems.liouvilleVonNeumann-Union{Tuple{T}, Tuple{B}, Tuple{T, Array, AbstractOperator{B, B}}} where {B<:Basis, T<:(Operator{B, B, T} where T)}","page":"Home","title":"OpenQuantumSystems.liouvilleVonNeumann","text":"liouvilleVonNeumann(rho0, tspan, H; \n\treltol=1.0e-12, abstol=1.0e-12, fout=nothing, alg=OrdinaryDiffEq.Tsit5())\n\nIntegrate Liouville-von Neumann equation to evolve states or compute propagators\n\nfracdd t rho(t) = - fracihbar  hat H rho(t)  quad hbar = 1.\n\nArguments\n\nrho0: Initial state vector (can be a bra or a ket) or initial propagator.\ntspan: Vector specifying the points of time for which output should be displayed.\nH: Arbitrary operator specifying the Hamiltonian.\nreltol: Relative tolerance for OrdinaryDiffEq solver and its inner states.\nabstol: Absolute tolerance for OrdinaryDiffEq solver and its inner states.\nfout=nothing: If given, this function fout(t, rho) is called every time       an output should be displayed. ATTENTION: The state rho is neither       normalized nor permanent! It is still in use by the ode solver and       therefore must not be changed.\nalg: Algorithm with which OrdinaryDiffEq will solve LvN equation.\n\n\n\n\n\n","category":"method"},{"location":"#OpenQuantumSystems.master-Union{Tuple{U}, Tuple{T}, Tuple{B}, Tuple{T, Any, U}} where {B<:Basis, T<:(Operator{B, B, T} where T), U<:(Operator{B, B, T} where T)}","page":"Home","title":"OpenQuantumSystems.master","text":"master(rho0, tspan, Ham; \n\treltol=1.0e-12, abstol=1.0e-12, int_reltol=1.0e-8, int_abstol=0.0, \n\tfout=nothing, alg=DelayDiffEq.MethodOfSteps(DelayDiffEq.Vern6()))\n\nIntegrate Quantum Master equation \n\nfracdd t rho(t) = - fracihbar  hatH rho(t_0)   -frac1hbar^2 int_t_0^t_1 textd tau   hatH  hatH rho(tau)   quad hbar = 1\n\nArguments\n\nrho0: Initial state vector (can be a bra or a ket) or initial propagator.\ntspan: Vector specifying the points of time for which output should be displayed.s\nHam: Arbitrary operator specifying the Hamiltonian.\nreltol: Relative tolerance for DiffEqCallbacks solver and its inner states.\nabstol: Absolute tolerance for DiffEqCallbacks solver and its inner states.\nint_reltol: Relative tolerance for QuadGK solver and its inner states.\nint_abstol: Absolute tolerance for QuadGK solver and its inner states.\nfout=nothing: If given, this function fout(t, rho) is called every time       an output should be displayed. ATTENTION: The state rho is neither       normalized nor permanent! It is still in use by the ode solver and       therefore must not be changed.\nalg: Algorithm with which DiffEqCallbacks will solve QME equation.\n\n\n\n\n\n","category":"method"},{"location":"#OpenQuantumSystems.master_int-Union{Tuple{V}, Tuple{U}, Tuple{T}, Tuple{B}, Tuple{T, Array, U, V}} where {B<:Basis, T<:(Operator{B, B, T} where T), U<:(Operator{B, B, T} where T), V<:(Operator{B, B, T} where T)}","page":"Home","title":"OpenQuantumSystems.master_int","text":"master_int(rho0, tspan, Ham_0, Ham_I; \n\treltol=1.0e-12, abstol=1.0e-12, int_reltol=1.0e-8, int_abstol=0.0, \n\tfout=nothing, alg=DelayDiffEq.MethodOfSteps(DelayDiffEq.Vern6()))\n\nIntegrate Quantum Master equation \n\nfracdd t rho^(I)(t) = - fracihbar  hatH_I^(I)(t) rho^(I)(t_0)   -frac1hbar^2 int_t_0^t_1 textd tau   hatH_I^(I)(t)  hatH_I^(I)(tau) rho^(I)(tau) \n\nH = H_S + H_B + H_I = H_0 + H_I quad hbar = 1\n\nArguments\n\nrho0: Initial state vector (can be a bra or a ket) or initial propagator.\ntspan: Vector specifying the points of time for which output should be displayed.s\nHam_0: System and bath Hamiltonian as Operator.\nHam_I: Interaction Hamiltonian as Operator.\nreltol: Relative tolerance for DiffEqCallbacks solver and its inner states.\nabstol: Absolute tolerance for DiffEqCallbacks solver and its inner states.\nint_reltol: Relative tolerance for QuadGK solver and its inner states.\nint_abstol: Absolute tolerance for QuadGK solver and its inner states.\nfout=nothing: If given, this function fout(t, rho) is called every time       an output should be displayed. ATTENTION: The state rho is neither       normalized nor permanent! It is still in use by the ode solver and       therefore must not be changed.\nalg: Algorithm with which DiffEqCallbacks will solve QME equation.\n\n\n\n\n\n","category":"method"},{"location":"#OpenQuantumSystems.schroedinger-Union{Tuple{T}, Tuple{B}, Tuple{T, Array, AbstractOperator{B, B}}} where {B<:Basis, T<:Union{AbstractOperator{B, B}, StateVector{B, T} where T<:(AbstractVector{T} where T)}}","page":"Home","title":"OpenQuantumSystems.schroedinger","text":"schroedinger(psi0, tspan, H; \n\treltol=1.0e-12, abstol=1.0e-12, fout=nothing, alg=OrdinaryDiffEq.Tsit5())\n\nIntegrate Schroedinger equation to evolve states or compute propagators\n\nfracdd tvertpsi(t)rangle = - fracihbar hat Hvertpsi(t)rangle quad hbar = 1.\n\nArguments\n\npsi0: Initial state vector (can be a bra or a ket) or initial propagator.\ntspan: Vector specifying the points of time for which output should be displayed.\nH: Arbitrary operator specifying the Hamiltonian.\nreltol: Relative tolerance for OrdinaryDiffEq solver and its inner states.\nabstol: Absolute tolerance for OrdinaryDiffEq solver and its inner states.\nfout=nothing: If given, this function fout(t, psi) is called every time       an output should be displayed. ATTENTION: The state psi is neither       normalized nor permanent! It is still in use by the ode solver and       therefore must not be changed.\nalg: Algorithm with which OrdinaryDiffEq will solve Schroedinger equation.\n\n\n\n\n\n","category":"method"},{"location":"#OpenQuantumSystems.schroedinger_dynamic-Union{Tuple{T}, Tuple{T, Array, Function}} where T<:Union{AbstractOperator, StateVector}","page":"Home","title":"OpenQuantumSystems.schroedinger_dynamic","text":"schroedinger_dynamic(psi0, tspan, f; \n\treltol=1.0e-12, abstol=1.0e-12, fout=nothing, alg=OrdinaryDiffEq.Tsit5())\n\nIntegrate time-dependent Schroedinger equation to evolve states or compute propagators\n\nfracdd tvertpsi(t)rangle = - fracihbar hat H(t)vertrho(t)rangle quad hbar = 1.\n\nArguments\n\npsi0: Initial state vector (can be a bra or a ket) or initial propagator.\ntspan: Vector specifying the points of time for which output should be displayed.\nf: Function f(t, psi) -> H returning the time and or state dependent Hamiltonian.\nreltol: Relative tolerance for OrdinaryDiffEq solver and its inner states.\nabstol: Absolute tolerance for OrdinaryDiffEq solver and its inner states.\nfout=nothing: If given, this function fout(t, psi) is called every time       an output should be displayed. ATTENTION: The state psi is neither       normalized nor permanent! It is still in use by the ode solver and       therefore must not be changed.\nalg: Algorithm with which OrdinaryDiffEq will solve Schroedinger equation.\n\n\n\n\n\n","category":"method"},{"location":"#OpenQuantumSystems.updateMolecule-Union{Tuple{Molecule{T, C1, C2}}, Tuple{C2}, Tuple{C1}, Tuple{T}} where {T<:Integer, C1<:Union{AbstractFloat, Complex}, C2<:Union{AbstractFloat, Complex}}","page":"Home","title":"OpenQuantumSystems.updateMolecule","text":"updateMolecule(mol)\n\nGet updated molecule with new params (e.g. Mode).\n\n\n\n\n\n","category":"method"},{"location":"#OpenQuantumSystems.vibrationalIndices-Union{Tuple{Aggregate{T, C1, C2}}, Tuple{C2}, Tuple{C1}, Tuple{T}} where {T<:Integer, C1<:Union{AbstractFloat, Complex}, C2<:Union{AbstractFloat, Complex}}","page":"Home","title":"OpenQuantumSystems.vibrationalIndices","text":"vibrationalIndices(agg)\n\nGet all vibrational indices of the Aggregate.\n\n\n\n\n\n","category":"method"},{"location":"#OpenQuantumSystems.vibrationalIndices-Union{Tuple{Vector{T}}, Tuple{T}} where T<:Integer","page":"Home","title":"OpenQuantumSystems.vibrationalIndices","text":"vibrationalIndices(maxInds)\n\nGet the vibrational indices for all states on Molecule.\n\nArguments\n\nmaxInds: Vector of maximum number of vibrational states.\n\n\n\n\n\n","category":"method"},{"location":"#QuantumOpticsBase.tracedistance-Union{Tuple{T}, Tuple{B}, Tuple{SuperOperator{B, B, T}, SuperOperator{B, B, T}}} where {B<:Tuple{Basis, Basis}, T}","page":"Home","title":"QuantumOpticsBase.tracedistance","text":"tracedistance(rho, sigma)\n\nTrace distance between rho and sigma. It is defined as\n\nT(ρσ) = frac12 Trsqrt(ρ - σ)^ (ρ - σ)\n\nIt calls tracenorm which in turn either uses tracenorm_h or tracenorm_nh depending if ρ-σ is hermitian or not.\n\n\n\n\n\n","category":"method"},{"location":"#QuantumOpticsBase.tracedistance_h-Union{Tuple{T}, Tuple{B}, Tuple{SuperOperator{B, B, T}, SuperOperator{B, B, T}}} where {B<:Tuple{Basis, Basis}, T}","page":"Home","title":"QuantumOpticsBase.tracedistance_h","text":"tracedistance_h(rho, sigma)\n\nTrace distance between rho and sigma. It uses the identity\n\nT(ρσ) = frac12 Trsqrt(ρ - σ)^ (ρ - σ) = frac12 sum_i λ_i\n\nwhere λ_i are the eigenvalues of rho - sigma.\n\n\n\n\n\n","category":"method"},{"location":"#QuantumOpticsBase.tracedistance_nh-Union{Tuple{T}, Tuple{B2}, Tuple{B1}, Tuple{SuperOperator{B1, B2, T}, SuperOperator{B1, B2, T}}} where {B1<:Tuple{Basis, Basis}, B2<:Tuple{Basis, Basis}, T}","page":"Home","title":"QuantumOpticsBase.tracedistance_nh","text":"tracedistance_nh(rho, sigma)\n\nTrace distance between rho and sigma. Note that in this case rho and sigma don't have to be represented by square matrices (i.e. they can have different left-hand and right-hand bases). It uses the identity\n\n    T(ρσ) = frac12 Trsqrt(ρ - σ)^ (ρ - σ)\n         = frac12 sum_i σ_i\n\nwhere σ_i are the singular values of rho - sigma.\n\n\n\n\n\n","category":"method"},{"location":"#QuantumOpticsBase.tracenorm-Tuple{DenseSuperOpType{BL, BR, var\"#s34\"} where {BL<:Tuple{Basis, Basis}, BR<:Tuple{Basis, Basis}, var\"#s34\"<:(Matrix{T} where T)}}","page":"Home","title":"QuantumOpticsBase.tracenorm","text":"tracenorm(rho)\n\nTrace norm of rho. It is defined as\n\nT(ρ) = Trsqrtρ^ ρ\n\nDepending if rho is hermitian either tracenorm_h or tracenorm_nh is called.\n\n\n\n\n\n","category":"method"},{"location":"#QuantumOpticsBase.tracenorm_h-Union{Tuple{SuperOperator{B, B, T}}, Tuple{T}, Tuple{B}} where {B<:Tuple{Basis, Basis}, T}","page":"Home","title":"QuantumOpticsBase.tracenorm_h","text":"tracenorm_h(rho)\n\nTrace norm of rho. It uses the identity\n\nT(ρ) = Trsqrtρ^ ρ = sum_i λ_i\n\nwhere λ_i are the eigenvalues of rho.\n\n\n\n\n\n","category":"method"},{"location":"#QuantumOpticsBase.tracenorm_nh-Union{Tuple{SuperOperator{B, B, T}}, Tuple{T}, Tuple{B}} where {B<:Tuple{Basis, Basis}, T}","page":"Home","title":"QuantumOpticsBase.tracenorm_nh","text":"tracenorm_nh(rho)\n\nTrace norm of rho. Note that in this case rho doesn't have to be represented by a square matrix (i.e. it can have different left-hand and right-hand bases). It uses the identity\n\n    T(ρ) = Trsqrtρ^ ρ = sum_i σ_i\n\nwhere σ_i are the singular values of rho.\n\n\n\n\n\n","category":"method"},{"location":"#OpenQuantumSystems.ShiftOperator","page":"Home","title":"OpenQuantumSystems.ShiftOperator","text":"ShiftOperator{BL,BR}(basis_l, basis_r, shift)\n\nDense shift operator as a mutable struct using the definition\n\nD(alpha) = exp(alpha a^dagger - alpha^* a).\n\nArguments\n\nbasis_l: Bra basis.\nbasis_r: Ket basis.\nshift: Shift or alpha parameter, can be complex number.\n\n\n\n\n\n","category":"type"},{"location":"#OpenQuantumSystems.integrate-Union{Tuple{X}, Tuple{T}, Tuple{Any, Function, X, T, T, Function}} where {T, X}","page":"Home","title":"OpenQuantumSystems.integrate","text":"integrate(tspan, df::Function, x0::Vector{ComplexF64},\n        state::T, dstate::T, fout::Function; kwargs...)\n\nIntegrate using OrdinaryDiffEq\n\n\n\n\n\n","category":"method"},{"location":"tutorials/B/#","page":"B site","title":"B site","text":"CurrentModule=OpenQuantumSystems","category":"page"},{"location":"tutorials/B/#B-site-1","page":"B site","title":"B site","text":"","category":"section"},{"location":"tutorials/B/#","page":"B site","title":"B site","text":"Example Julia package repo.","category":"page"}]
}
