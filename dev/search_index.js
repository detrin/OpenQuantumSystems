var documenterSearchIndex = {"docs":
[{"location":"tutorials/A/#","page":"A site","title":"A site","text":"CurrentModule=OpenQuantumSystems","category":"page"},{"location":"tutorials/A/#A-site-1","page":"A site","title":"A site","text":"","category":"section"},{"location":"tutorials/A/#","page":"A site","title":"A site","text":"Example Julia package repo.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"CurrentModule=OpenQuantumSystems","category":"page"},{"location":"#OpenQuantumSystems-1","page":"Home","title":"OpenQuantumSystems","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"OpenQuantumSystems.jl may help you with simulating common open quantum systems with main focus on systems connected to quantum biology. ","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Documentation is under construction. ","category":"page"},{"location":"#","page":"Home","title":"Home","text":"(Image: under construction)","category":"page"},{"location":"#Installation-1","page":"Home","title":"Installation","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"You can obtain OpenQuantumSystems using Julia's Pkg REPL-mode (hitting ] as the first character of the command prompt):","category":"page"},{"location":"#","page":"Home","title":"Home","text":"(v1.6) pkg> add OpenQuantumSystems","category":"page"},{"location":"#","page":"Home","title":"Home","text":"or with using Pkg; Pkg.add(\"OpenQuantumSystems\").","category":"page"},{"location":"#Documentation-1","page":"Home","title":"Documentation","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"Modules = [OpenQuantumSystems]","category":"page"},{"location":"#OpenQuantumSystems.AnnihilationOperator","page":"Home","title":"OpenQuantumSystems.AnnihilationOperator","text":"AnnihilationOperator{BL,BR}(basis_l, basis_r)\n\nCreate dense annihilation operator mutable struct.\n\n\n\n\n\n","category":"type"},{"location":"#OpenQuantumSystems.CreationOperator","page":"Home","title":"OpenQuantumSystems.CreationOperator","text":"CreationOperator{BL,BR}(basis_l, basis_r)\n\nCreate dense creation operator mutable struct.\n\n\n\n\n\n","category":"type"},{"location":"#OpenQuantumSystems.Mode","page":"Home","title":"OpenQuantumSystems.Mode","text":"Mode{T}(omega, shift)\n\nMutable stuct which purpose is to model vibrational LHO mode.\n\nV(q) = hbar omega (q - q_0)^2\n\nArguments\n\nomega: The frequency of LHO (omega).\nshift: The shift of the coordinate of LHO (q_0).\n\n\n\n\n\n","category":"type"},{"location":"#OpenQuantumSystems.Commutator-Tuple{Operator}","page":"Home","title":"OpenQuantumSystems.Commutator","text":"Commutator(A)\n\nCreate commutator as in a form of superoperator from a given operator.\n\ntextCommutator(A) cdot = A cdot\n\n\n\n\n\n","category":"method"},{"location":"#OpenQuantumSystems.OneDenseOperator-Union{Tuple{BR}, Tuple{BL}, Tuple{BL, BR}} where {BL<:Basis, BR<:Basis}","page":"Home","title":"OpenQuantumSystems.OneDenseOperator","text":"OneDenseOperator(basis_l, basis_r)\n\nCreates DenseOperator with ones on the diagonal.\n\n\n\n\n\n","category":"method"},{"location":"#OpenQuantumSystems.schroedinger-Union{Tuple{T}, Tuple{B}, Tuple{T, Array, AbstractOperator{B, B}}} where {B<:Basis, T<:Union{AbstractOperator{B, B}, StateVector{B, T} where T<:(AbstractVector{T} where T)}}","page":"Home","title":"OpenQuantumSystems.schroedinger","text":"schroedinger(tspan, psi0, H; fout)\n\nIntegrate Schroedinger equation to evolve states or compute propagators.\n\nArguments\n\npsi0: Initial state vector (can be a bra or a ket) or initial propagator.\nH: Arbitrary operator specifying the Hamiltonian.\ntspan: Vector specifying the points of time for which output should be displayed.\nfout=nothing: If given, this function fout(t, psi) is called every time       an output should be displayed. ATTENTION: The state psi is neither       normalized nor permanent! It is still in use by the ode solver and       therefore must not be changed.\n\n\n\n\n\n","category":"method"},{"location":"#OpenQuantumSystems.schroedinger_dynamic-Union{Tuple{T}, Tuple{T, Array, Function}} where T<:Union{AbstractOperator, StateVector}","page":"Home","title":"OpenQuantumSystems.schroedinger_dynamic","text":"schroedinger_dynamic(tspan, psi0, f; fout)\n\nIntegrate time-dependent Schroedinger equation to evolve states or compute propagators.\n\nArguments\n\ntspan: Vector specifying the points of time for which output should be displayed.\npsi0: Initial state vector (can be a bra or a ket) or initial propagator.\nf: Function f(t, psi) -> H returning the time and or state dependent Hamiltonian.\nfout=nothing: If given, this function fout(t, psi) is called every time       an output should be displayed. ATTENTION: The state psi is neither       normalized nor permanent! It is still in use by the ode solver and       therefore must not be changed.\n\n\n\n\n\n","category":"method"},{"location":"#QuantumOpticsBase.tracedistance-Union{Tuple{T}, Tuple{B}, Tuple{SuperOperator{B, B, T}, SuperOperator{B, B, T}}} where {B<:Tuple{Basis, Basis}, T}","page":"Home","title":"QuantumOpticsBase.tracedistance","text":"tracedistance(rho, sigma)\n\nTrace distance between rho and sigma. It is defined as\n\nT(ρσ) = frac12 Trsqrt(ρ - σ)^ (ρ - σ)\n\nIt calls tracenorm which in turn either uses tracenorm_h or tracenorm_nh depending if ρ-σ is hermitian or not.\n\n\n\n\n\n","category":"method"},{"location":"#QuantumOpticsBase.tracedistance_h-Union{Tuple{T}, Tuple{B}, Tuple{SuperOperator{B, B, T}, SuperOperator{B, B, T}}} where {B<:Tuple{Basis, Basis}, T}","page":"Home","title":"QuantumOpticsBase.tracedistance_h","text":"tracedistance_h(rho, sigma)\n\nTrace distance between rho and sigma. It uses the identity\n\nT(ρσ) = frac12 Trsqrt(ρ - σ)^ (ρ - σ) = frac12 sum_i λ_i\n\nwhere λ_i are the eigenvalues of rho - sigma.\n\n\n\n\n\n","category":"method"},{"location":"#QuantumOpticsBase.tracedistance_nh-Union{Tuple{T}, Tuple{B2}, Tuple{B1}, Tuple{SuperOperator{B1, B2, T}, SuperOperator{B1, B2, T}}} where {B1<:Tuple{Basis, Basis}, B2<:Tuple{Basis, Basis}, T}","page":"Home","title":"QuantumOpticsBase.tracedistance_nh","text":"tracedistance_nh(rho, sigma)\n\nTrace distance between rho and sigma. Note that in this case rho and sigma don't have to be represented by square matrices (i.e. they can have different left-hand and right-hand bases). It uses the identity\n\n    T(ρσ) = frac12 Trsqrt(ρ - σ)^ (ρ - σ)\n         = frac12 sum_i σ_i\n\nwhere σ_i are the singular values of rho - sigma.\n\n\n\n\n\n","category":"method"},{"location":"#QuantumOpticsBase.tracenorm-Tuple{DenseSuperOpType{BL, BR, var\"#s34\"} where {BL<:Tuple{Basis, Basis}, BR<:Tuple{Basis, Basis}, var\"#s34\"<:(Matrix{T} where T)}}","page":"Home","title":"QuantumOpticsBase.tracenorm","text":"tracenorm(rho)\n\nTrace norm of rho. It is defined as\n\nT(ρ) = Trsqrtρ^ ρ\n\nDepending if rho is hermitian either tracenorm_h or tracenorm_nh is called.\n\n\n\n\n\n","category":"method"},{"location":"#QuantumOpticsBase.tracenorm_h-Union{Tuple{SuperOperator{B, B, T}}, Tuple{T}, Tuple{B}} where {B<:Tuple{Basis, Basis}, T}","page":"Home","title":"QuantumOpticsBase.tracenorm_h","text":"tracenorm_h(rho)\n\nTrace norm of rho. It uses the identity\n\nT(ρ) = Trsqrtρ^ ρ = sum_i λ_i\n\nwhere λ_i are the eigenvalues of rho.\n\n\n\n\n\n","category":"method"},{"location":"#QuantumOpticsBase.tracenorm_nh-Union{Tuple{SuperOperator{B, B, T}}, Tuple{T}, Tuple{B}} where {B<:Tuple{Basis, Basis}, T}","page":"Home","title":"QuantumOpticsBase.tracenorm_nh","text":"tracenorm_nh(rho)\n\nTrace norm of rho. Note that in this case rho doesn't have to be represented by a square matrix (i.e. it can have different left-hand and right-hand bases). It uses the identity\n\n    T(ρ) = Trsqrtρ^ ρ = sum_i σ_i\n\nwhere σ_i are the singular values of rho.\n\n\n\n\n\n","category":"method"},{"location":"#OpenQuantumSystems.ShiftOperator","page":"Home","title":"OpenQuantumSystems.ShiftOperator","text":"CreationOperator{BL,BR}(basis_l, basis_r, shift)\n\nCreate dense creation operator mutable struct using the definition.\n\nD(alpha) = exp(alpha a^dagger - alpha^* a)\n\nArguments\n\nbasis_l: Bra basis.\nbasis_r: Ket basis.\nshift: Shift or alpha parameter, can be complex number.\n\n\n\n\n\n","category":"type"},{"location":"#OpenQuantumSystems.integrate-Union{Tuple{X}, Tuple{T}, Tuple{Any, Function, X, T, T, Function}} where {T, X}","page":"Home","title":"OpenQuantumSystems.integrate","text":"integrate(tspan, df::Function, x0::Vector{ComplexF64},\n        state::T, dstate::T, fout::Function; kwargs...)\n\nIntegrate using OrdinaryDiffEq\n\n\n\n\n\n","category":"method"},{"location":"#OpenQuantumSystems.@skiptimechecks-Tuple{Any}","page":"Home","title":"OpenQuantumSystems.@skiptimechecks","text":"@skiptimechecks\n\nMacro to skip checks during time-dependent problems. Useful for master_dynamic and similar functions.\n\n\n\n\n\n","category":"macro"},{"location":"tutorials/B/#","page":"B site","title":"B site","text":"CurrentModule=OpenQuantumSystems","category":"page"},{"location":"tutorials/B/#B-site-1","page":"B site","title":"B site","text":"","category":"section"},{"location":"tutorials/B/#","page":"B site","title":"B site","text":"Example Julia package repo.","category":"page"}]
}
